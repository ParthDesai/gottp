{"name":"Gottp","tagline":"A tiny golang web framework","body":"### [![Build Status](https://travis-ci.org/Simversity/gottp.svg?branch=master)](https://travis-ci.org/Simversity/gottp)\r\n\r\ngottp\r\n=====\r\n\r\nGottp is not a regular front-end server to do user-facing CSS powered websites. It was designed using backend servers in mind and offers a variety of features like:\r\n\r\n* Call Aggregation using Non-Blocking or Blocking Pipes. [1]\r\n* Optionally Listens on Unix Domain socket.\r\n* In-built error traceback emails.\r\n* Optional data compression using zlib/gzip.\r\n* Pagination support.\r\n* Automatic listing of all exposed URLs\r\n\r\n[1] Much like Batch requests in Facebook Graph API (https://developers.facebook.com/docs/graph-api/making-multiple-requests)\r\n\r\n\r\nInstallation\r\n=============\r\n\r\nInstallation is as easy as:\r\n\r\n```\r\ngo get github.com/Simversity/gottp\r\n```\r\n\r\nGetting Started\r\n===============\r\n\r\n*A sample application named helloWorld is available inside the tests directory of your checkout*\r\n\r\nTo start building a web service using gottp just create a new project with the following structure.\r\n\r\n* conf.go -> Configuration\r\n* main.go -> main Server engine\r\n* urls.go -> Register urls & corresponding handlers.\r\n* handlers.go -> handlers processing the request.\r\n\r\nconf.go\r\n-------\r\n\r\nThis section is applicable only when you need to provide application based settings alongside those used by gottp.\r\n\r\nConfiguration must implement the Configurer interface.\r\n\r\nConfigurer requires two method Sets:\r\n\r\n* MakeConfig(string) which accepts the path of the .cfg file provided as an command line argument.\r\n* GetGottpConfig() which must return the Settings\r\n\r\n```\r\ntype Configurer interface {\r\n    MakeConfig(string)\r\n        GetGottpConfig() *GottpSettings\r\n}\r\n```\r\n\r\nA minimalist extended configuration looks like:\r\n\r\n```\r\nimport (\r\n        \"github.com/Simversity/gottp/conf\"\r\n       )\r\n\r\ntype config struct {\r\n    Custom struct {\r\n        VarOne string\r\n            VarTwo string\r\n    }\r\n    Gottp conf.GottpSettings\r\n}\r\n\r\nfunc (self *config) MakeConfig(configPath string) {\r\n    if configPath != \"\" {\r\n        conf.MakeConfig(configPath, self)\r\n    }\r\n}\r\n\r\nfunc (self *config) GetGottpConfig() *conf.GottpSettings {\r\n    return &self.Gottp\r\n}\r\n\r\nvar settings config\r\n```\r\n\r\nurls.go\r\n-------\r\n\r\nA sample urls.go looks like:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n        \"github.com/Simversity/gottp\"\r\n       )\r\n\r\nvar urls = []*gottp.Url{\r\n    gottp.NewUrl(\"hello\", \"/hello/\\\\w{3,5}/?$\", handlers.HelloMessage),\r\n}\r\n```\r\n\r\nThis would match all urls that are like \"/hello/world\" or \"/hello/greet\" but NOT /hello/123 and not /hello/yester\r\n\r\n\r\nhandlers.go\r\n-----------\r\n\r\nA sample handler looks like:\r\n\r\n```\r\npackage handlers\r\n\r\nimport (\r\n        \"github.com/Simversity/gottp\"\r\n       )\r\n\r\nfunc HelloMessage(req *gottp.Request) {\r\n    req.Write(\"hello world\")\r\n}\r\n```\r\n\r\nmain.go\r\n-------\r\n\r\nA sample main.go looks like:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n        \"log\"\r\n        \"github.com/Simversity/gottp\"\r\n       )\r\n\r\nfunc main() {\r\n    gottp.BindHandlers(urls) //Urls is a slice of all the registered urls.\r\n        gottp.MakeServer(&settings)\r\n}\r\n\r\n```\r\n\r\nBuild & Run\r\n-----------\r\n\r\n```\r\ngo install test && test\r\n```\r\n\r\nPoint your browser to http://127.0.0.1:8005/hello/check\r\n\r\nShould give you a JSON output:\r\n\r\n```\r\n{\r\n    \"data\": \"hello world\",\r\n        \"message\": \"\",\r\n        \"status\": 200\r\n}\r\n```\r\n\r\nConfiguration\r\n-------------\r\n\r\nGottp allows you to provide .cfg files via the command line which is as easy as ./binary -config=path_to_cfg\r\n\r\nDefault gottp settings is a struct called GottpSettings\r\n\r\n```\r\ntype GottpSettings struct {\r\n    EmailHost     string //SMTP Host to send server Tracebacks.\r\n        EmailPort     string //SMTP Port\r\n        EmailUsername string //Username or Password to connect with SMTP\r\n        EmailPassword string\r\n        EmailSender   string   //Sender Name to be used for traceback.\r\n        EmailFrom     string   //Verified sender email address like errors@example.com\r\n        ErrorTo       []string //List of recipients for tracebacks.\r\n        EmailDummy    bool     //Set to True, if Tracebacks should not be sent.\r\n        Listen        string   //Address to Listen on default: 127.0.0.1:8005\r\n}\r\n```\r\n\r\n.cfg sample\r\n-----------\r\n\r\nYou can provide a simple configuration file in .cfg format to load the settings which would look like this:\r\n\r\n```\r\n[custom]\r\nVarOne=\"one\"\r\nVarTwo=\"two\"\r\n\r\n[gottp]\r\nlisten=\"/tmp/custom.sock\"\r\nEmailHost=\"email-smtp.us-east-1.amazonaws.com\"\r\nEmailPort=\"587\"\r\nEmailPassword=\"TDVAGCWCTCTWCTCQ&&*!!*!*!*/NeURB5\"\r\nEmailUsername=\"HelloWorldSample\"\r\nEmailSender=\"My Gottp Server\"\r\nEmailFrom=\"errors@example.com\"\r\nErrorTo=\"dev@example.com\"\r\nEmailDummy=false\r\n```\r\n\r\nURLs\r\n----\r\n\r\nUrls are of type gottp.Url\r\n\r\n```\r\ntype Url struct {\r\n    name    string //shortname of the url\r\n        url     string //provided regular pattern\r\n        handler func(r *Request) //ReuqestHandler\r\n        pattern *regexp.Regexp //Compiled Regular Expression\r\n}\r\n```\r\n\r\nURLs can be constructed using gottp.NewUrl which accepts shortname, regular expression & request Handler respectively.\r\n\r\n\r\nRequest Handler\r\n---------------\r\n\r\nA request handler supplied to URLs can be a function or a closure that accepts gottp.Request as argument.\r\n\r\nHandler is responsible for writing the request data using request.Write(). Do note that gottp is purely JSON based so data is written with headers application/json.\r\n\r\nThis can be improved with time, I intend to support other content-types by exposing extensible middlewares.\r\n\r\nRequest exposes a few method structs:\r\n\r\nGetArguments() *utils.Q\r\n\r\n_\r\nReturns a map of all arguments passed to the request. This includes Body arguments in case of a PUT/POST request, url GET arguments and named arguments captured in URL regular expression. You can call this over as it handles caching internally.\r\n_\r\n\r\nGetArgument(key string) interface{}\r\n\r\nConvertArguments(dest interface{})\r\nConvertArgument(key string, dest interface{})\r\n\r\nThese methods come quite handy when you have to deal with the arguments. For a request with GET arguments that look like:\r\n\r\n```\r\n?abc=world&param=1&check=0\r\n```\r\n\r\nYou can either fetch individual arguments like:\r\n\r\n```\r\nabcVar, _ := req.GetArgument(\"abc\").(string)\r\nlog.Println(abcVar)\r\n```\r\n\r\nOr initialize a struct to convert all the arguments:\r\n\r\n```\r\ntype params struct {\r\n  abc string\r\n  param int\r\n  check int\r\n}\r\n\r\ngetArgs := params{}\r\nreq.ConvertArguments(&getArgs)\r\nlog.Println(getArgs.abc)\r\n```\r\n\r\nAvailable URLs\r\n==============\r\n\r\nWith backends powered by Gottp, consumers can simply access http://{host}:{port}/urls to fetch a json of all URLs exposed by the application. URLs are returned as a map of key: pattern where the key is the human-readable-identifier provided at the time of constructing URLS and the pattern is the URL regular expression pattern.\r\n\r\nThis helps in preventing hard coding of endpoints where consumers can fetch the URLs at application start time and reconstruct URLs using the indentifiers.\r\n\r\nSample Output:\r\n\r\n```\r\n{\r\n  \"data\": {\r\n    \"hello\": \"/hello/\\\\w{3,5}/?$\"\r\n  },\r\n  \"message\": \"\",\r\n  \"status\": 200\r\n}\r\n```\r\n\r\nPipes\r\n=====\r\n\r\nAll gottp based servers allow clubbing of requests to be executed together. This is a very handy feature that is used for clubbing calls that need to processed one after the other. It can save the network handshaking costs as the handshake is only performed once and this does not effect server performance as all gottp requests are performed as goroutines.\r\n\r\nSequential Pipes\r\n----------------\r\n\r\nExample usage of such calls is:\r\n\r\n1. Create a Comment\r\n2. Mark the parent notification as read\r\n3. Send out notification to the parent autho\r\n4. Churn the new activity feed as per edge rank.\r\n\r\nUsing Pipes, call 1, 2, 3 & 4 can be combined into a single request to the server.\r\n\r\nAll the requests would sequentially evaluated and data would be returned in the same order as requested.\r\n\r\nTo submit a PIPE request issue a POST call on /pipe (available by default).\r\n\r\nAsync Pipes\r\n-----------\r\n\r\nAsync pipes behave the same way, except the requests are executed in parallel\r\nas go-routines. Async pipes are as fast as the slowest call in your request\r\nstack.\r\n\r\nDespite parallel execution they return the data in the same order as requested.\r\n\r\nTo submit an Async PIPE request issue a POST call on /async-pipe (available by default)\r\n\r\nPipe Request Object\r\n-------------------\r\n\r\nRequests submitted as PIPEs should again be a valid JSON dump of\r\n\r\n```\r\n{\r\n    \"stack\": [\r\n        {\"url\": \"/url1\", \"method\": \"POST\", \"data\": {\"sample\": \"json\"}},\r\n        {\"url\": \"/url2\", \"method\": \"GET\", \"data\": {\"get\": \"argument\"}},\r\n        ...\r\n    ]\r\n}\r\n```\r\n\r\nError Reporting\r\n===============\r\n\r\nGottp can send error tracebacks if a request failed.\r\nThis can be enabled by setting EmailDummy as false in the gottp section of cfg.\r\n\r\nA sample traceback email looks like this:\r\n\r\n![Sample Traceback](http://test.simversity.com.s3.amazonaws.com/original_image/142052802943405598970493/emailtraceback.png)\r\n\r\nTODO: Expose a way to use custom email templates.\r\n","google":"UA-54802717-1","note":"Don't delete this file! It's used internally to help with page regeneration."}